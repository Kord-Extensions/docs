<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Components ✏️" id="Components">

    <show-structure depth="2"/>

    <p>
        Discord provides several
        <a href="https://discord.com/developers/docs/interactions/message-components">Message Components</a>,
        allowing for more advanced forms of user interactions.
        Kord Extensions exposes these via its components system.
    </p>

    <p>
        When a user interacts with a component, Discord fires a corresponding interaction event.
        You may handle these events in two ways, depending on what you're trying to do and how long-lived your
        components should be.
	    We've covered both approaches below.
    </p>

    <list>
        <li>
            <format style="bold">Short-lived components that don’t persist:</format>
            The convenience API provided by the <code>components</code> builder and <code>ComponentContainer</code>
            type.
        </li>

        <li>
            <format style="bold">Long-lived components that must work after the bot restarts:</format>
            Writing an <a href="Events.topic">Event Handler</a> by yourself.
        </li>
    </list>

    <chapter title="Understanding Components" id="understanding-components">
        <p>
            As Discord states, components are a framework for adding interactive elements to the messages your app or
            bot sends.
            Several types of components exist, and they're only available in specific contexts:
        </p>

        <table style="both">
            <tr>
                <td>Type</td>
                <td>Units</td>
                <td>Description</td>
                <td>Messages</td>
                <td>Modals</td>
            </tr>

            <tr>
                <td>Action Row</td>
                <td>Five</td>

                <td>
                    Container for other components, up to five rows per context.
                    Each row has a width of five units.
                </td>

                <td>✅ Yes</td>
                <td>✅ Yes</td>
            </tr>

            <tr>
                <td>Button</td>
                <td>One</td>
                <td>Clickable button.</td>
                <td>✅ Yes</td>
                <td>❌ No</td>
            </tr>

            <tr>
                <td>Select Menu</td>
                <td>Five</td>

                <td>
                    Dropdown menu for selecting zero, one, or multiple items.
                    Supports multiple data types: channels, mentionables, roles, strings, and users.
                </td>

                <td>✅ Yes</td>
                <td>❌ No</td>
            </tr>

            <tr>
                <td>Text Input</td>
                <td>Five</td>
                <td>Field that a user may use to input one or multiple lines of text.</td>
                <td>❌ No</td>
                <td>✅ Yes</td>
            </tr>
        </table>

        <chapter title="Action Rows" id="understanding-action-rows">
            <p>
                Action rows act as a container for other components, and they must be used anywhere you wish to use a
                component.
                You may only have up to five rows of components in any single context.
            </p>

            <img alt="Graphic depicting an action row. It shows a row with five empty slots."
                 src="action-row-empty.png"
            />

            <p>
                Each component has a width measured in "units."
                Action rows are five units wide, and thus may contain components up to a total width of five units.
                If an action row contains multiple components, there shouldn’t be any gaps between them.
            </p>

            <img alt="Graphic depicting an example message with five empty action rows positioned below."
                 src="action-row-example.png"
            />
        </chapter>

        <chapter title="Buttons" id="understanding-buttons">
            <p>
                Buttons are clickable/tappable components, which the user may interact with to trigger an action or
                open a link.
                They’re the only component type with a width of one unit, and thus they’re the only type of
                component that can appear multiple times in a single row.
            </p>

            <p>
	            You may only add Buttons to messages.
	            You can't add them to modals.
            </p>

            <img alt="Graphic depicting an action row with a single button and four empty slots."
                 src="action-row-button.png"
            />

            <img alt="Graphic depicting an action row with three buttons and two empty slots."
                 src="action-row-buttons.png"
            />

            <p>
                Several types of buttons exist:
            </p>

            <list>
                <li>
                    <format style="bold">Action Buttons:</format>
                    Buttons which trigger an event when interacted with,
                    which your bot may react to.
                </li>

                <li>
                    <format style="bold">Disabled Buttons:</format>
                    Buttons which don't do anything when interacted
                    with.
                </li>

                <li>
                    <format style="bold">Link Buttons:</format>
                    Buttons which open a predefined URL in the user's
                    browser when interacted with.
                </li>
            </list>
        </chapter>

        <chapter title="Select Menus" id="understanding-select-menus">
            <p>
                Select Menus represent dropdown menus, allowing users to select zero, one, or multiple options from a
                set of 25.
                Select Menus have a width of five units, meaning they take up an entire row.
            </p>

            <p>
	            You may only add Select Menus to messages.
	            You can't add them to modals.
            </p>

            <img alt="Graphic depicting an action row with a single select menu. The select menu spans all five slots, with no empty slots."
                 src="action-row-select-menu.png"
            />

            <p>
                Select menus support several types of data:
            </p>

            <list>
                <li>Channels</li>
                <li>Mentionables (channels, roles and users)</li>
                <li>Roles</li>
                <li>Strings</li>
                <li>Users</li>
            </list>
        </chapter>

        <chapter title="Text Inputs" id="understanding-text-inputs">
            <p>
                Text Inputs represent editable text fields, allowing users to input arbitrary data.
                Text Inputs have a width of five units, meaning they take up an entire row.
            </p>

            <p>
                You may only add Text Inputs to modals.
                You can't add them to messages.
            </p>

            <img alt="Graphic depicting an action row with a single text input. The text input spans all five slots, with no empty slots."
                 src="action-row-text.png"
            />

            <p>
                Text Inputs support two different form factors:
            </p>

            <list>
                <li>Line, for a single line of text.</li>
                <li>Paragraph, for a larger, multi-line block of text.</li>
            </list>
        </chapter>
    </chapter>

    <chapter title="Message Components" id="message-components">
        <p>
            Kord Extensions provides a convenient API for shorter-lived message components.
            The <code>ComponentContainer</code> class is the core type representing this API.
        </p>

        <p>
            To get started, use the <code>components</code> builder.
            This builder is available for use in all message creation and editing builders.
        </p>

        <note>
            <p>
                Kord Extensions doesn't provide an atomic API for modifying your components after you've sent them to
                Discord.
                This is mostly due to technical limitations within Kotlin's type system, and it is unlikely this
                will change any time soon.
            </p>

            <p>
                If you wish to edit components, we suggest keeping a reference to the <code>ComponentContainer</code>
                returned by the <code>components</code> builder, and any relevant components that you create.
                The components within any given <code>ComponentContainer</code> may be applied to any message
                creation/editing builder via the <code>applyComponents</code> extension function.
            </p>
        </note>

        <code-block lang="kotlin" collapsible="true" collapsed-title="Example Usage">
            channel.createMessage {
                components {
                    publicButton {
                        label = "OK"
                        style = ButtonStyle.Success

                        action {
                            respond {
                                content = "Clicked: **OK**"
                            }
                        }
                    }

                    publicButton {
                        label = "Cancel"
                        style = ButtonStyle.Danger

                        action {
                            respond {
                                content = "Clicked: **Cancel**"
                            }
                        }
                    }
                }
            }
        </code-block>

        <chapter title="Components DSL" id="message-components-dsl">
			<p>
				The <code>components</code> DSL function accepts extra arguments:
			</p>

	        <list>
		        <li>
			        <code>timeout</code>, an optional timeout <code>Duration</code>.
			        This argument allows you to specify how long to wait (since the components were last interacted
			        with) until the bot should stop waiting for interactions.
			        Defaults to <code>null</code>, meaning the components will work until the bot restarts.
		        </li>
	        </list>

	        <p>
		        This function requires a callable block, a receiver on the <code>ComponentContainer</code> type.
		        You should use this block to define the components to add to the message.
		        The <code>ComponentContainer</code> will be returned by the function.
	        </p>

	        <p>
		        The <code>ComponentContainer</code> class is <code>open</code>, and may be extended for advanced
		        use-cases.
		        If you need to create your own objects based on this class, you can use the <code>applyComponents</code>
		        extension function available in all message creation/editing builders to apply its contents.
	        </p>

	        <chapter title="Adding Components" id="message-components-adding">
		        <p>
			        When adding components to messages directly, you need to define action rows for your components,
			        and space them out yourself.
			        The <code>ComponentContainer</code> still allows you to specify the rows your components belong to.
			        However, for components with undefined rows, it will attempt to automatically pack them as tightly
			        as possible, in the order they were defined.
			        This automatic packing happens after your components are defined,
		        </p>

		        <p>
			        For example, if you provide a select menu, six buttons and another select menu, then the container
			        packs your components into rows that look like this:
		        </p>

		        <list type="decimal">
			        <li>Select menu</li>
			        <li>Five buttons</li>
			        <li>One button</li>
			        <li>Select menu</li>
			        <li>Nothing</li>
		        </list>

		        <p>
					If needed, you can provide row numbers when you define your components.
			        When you provide a row number, the container packs the component within the specified row
			        <format style="bold">immediately</format>.
			        If you combine this approach by also defining unsorted components (as mentioned above), the
			        container packs the unsorted components
			        <format style="bold">alongside those with defined rows</format>, attempting to fill the rows up as
			        tightly as possible.
		        </p>

		        <p>
			        For example, if you provide a select menu on row 2, six unsorted buttons, and another select menu
			        on row 3, then the container packs your components into rows that look like this:
		        </p>

		        <list type="decimal">
			        <li>Five buttons</li>
			        <li>Select menu</li>
			        <li>Select menu</li>
			        <li>One button</li>
			        <li>Nothing</li>
		        </list>
	        </chapter>

	        <chapter title="DSL Functions" id="message-components-dsl-functions">
				<p>
					The following functions are available for component creation.
					We've split these by interaction type, just like the
					<a href="Application-Commands.topic">Application Command</a> DSL functions.
				</p>

		        <table style="header-row">
			        <tr>
				        <td>Name</td>
				        <td>Component</td>
			        </tr>

			        <tr>
				        <td><code>disabledButton</code></td>
				        <td>Button (Disabled)</td>
			        </tr>

			        <tr>
				        <td><code>ephemeralButton</code></td>
				        <td>Button (Interactive)</td>
			        </tr>

			        <tr>
				        <td><code>linkButton</code></td>
				        <td>Button (Link)</td>
			        </tr>

			        <tr>
				        <td><code>publicButton</code></td>
				        <td>Button (Interactive)</td>
			        </tr>

			        <tr id="components-dsl-select-menus:div:top">
				        <td><code>ephemeralChannelSelectMenu</code></td>
				        <td>Select Menu (Channel)</td>
			        </tr>

			        <tr>
				        <td><code>ephemeralRoleSelectMenu</code></td>
				        <td>Select Menu (Role)</td>
			        </tr>

			        <tr>
				        <td><code>ephemeralStringSelectMenu</code></td>
				        <td>Select Menu (String)</td>
			        </tr>

			        <tr>
				        <td><code>ephemeralUserSelectMenu</code></td>
				        <td>Select Menu (User)</td>
			        </tr>

			        <tr>
				        <td><code>publicChannelSelectMenu</code></td>
				        <td>Select Menu (Channel)</td>
			        </tr>

			        <tr>
				        <td><code>publicRoleSelectMenu</code></td>
				        <td>Select Menu (Role)</td>
			        </tr>

			        <tr>
				        <td><code>publicStringSelectMenu</code></td>
				        <td>Select Menu (String)</td>
			        </tr>

			        <tr>
				        <td><code>publicUserSelectMenu</code></td>
				        <td>Select Menu (User)</td>
			        </tr>
		        </table>
	        </chapter>

	        <chapter title="Component Container API" id="component-container-api">
				<p>
					The <code>ComponentContainer</code> type exposes several useful APIs.
					The <code>components</code> DSL function is a receiver for an object of this type, and it also
					returns that object.
				</p>

		        <chapter title="Functions" id="component-container-api-functions">
					<table style="header-row">
						<tr>
							<td>Name</td>
							<td>Description</td>
						</tr>

						<tr>
							<td><code>add</code></td>

							<td>
								Manually add a component to this container.
							</td>
						</tr>

						<tr>
							<td><code>cancel</code></td>

							<td>
								Cancel the timeout task, and remove all components from this container.
								This is equivalent to timing out the container early, but it will not run the
								callback defined via the <code>onTimeout</code> function.
								<format style="bold">Note:</format> This will not update the components in any related
								messages — you'll need to edit them to clear their components manually.
							</td>
						</tr>

						<tr>
							<td><code>onTimeout</code></td>

							<td>
								Register the callback to be run when the container times out.
								<format style="bold">Note:</format> The <code>cancel</code> function won't run this
								callback.
							</td>
						</tr>

						<tr>
							<td><code>remove</code></td>

							<td>
								Remove the given component from the container, and prevent it from being used.
								<format style="bold">Note:</format> This will not update the components in any related
								messages — use the <code>applyToMessage</code> function to do so.
							</td>
						</tr>

						<tr>
							<td><code>removeAll</code></td>

							<td>
								Remove all components from the container, and prevent them from being used.
								<format style="bold">Note:</format> This will not update the components in any related
								messages — use the <code>applyToMessage</code> function to do so.
							</td>
						</tr>

						<tr>
							<td><code>replace</code></td>

							<td>
								Replace a component within this container with another.
								<format style="bold">Note:</format> This will not update the components in any related
								messages — use the <code>applyToMessage</code> function to do so.
							</td>
						</tr>

						<tr>
							<td><code>sort</code></td>

							<td>
								Pack any unsorted components into rows.
								<format style="bold">Note:</format> You generally won't need to call this function
								yourself.
							</td>
						</tr>
					</table>

			        <table style="header-row">
				        <tr>
					        <td>Receiver</td>
					        <td>Name</td>
					        <td>Description</td>
				        </tr>

				        <tr>
					        <td><code>MessageBuilder</code></td>
					        <td><code>applyToMessage</code></td>

					        <td>
						        Apply the components within this container to the given message builder.
					        </td>
				        </tr>
			        </table>
		        </chapter>

		        <chapter title="Properties" id="component-container-api-properties">
					<table style="header-row">
						<tr>
							<td>Name</td>
							<td>Type</td>
							<td>Description</td>
						</tr>

						<tr>
							<td><code>rows</code></td>
							<td><code>Array&lt;MutableList&lt;Component&gt;&gt;</code></td>

							<td>
								An array representing sorted rows of components.
								The <code>sort</code> function fills this.
							</td>
						</tr>

						<tr>
							<td><code>timeout</code></td>
							<td><code>Duration?</code></td>

							<td>
								If defined, the container will remove and unregister its components once it reaches the
								timeout, unless component interactions have happened.
								When interactions happen, the timeout resets.
							</td>
						</tr>

						<tr>
							<td><code>timeoutCallback</code></td>
							<td><code>ComponentContainer.() -> Unit</code></td>

							<td>
								A callback run when the timeout expires.
								Defined by the <code>onTimeout</code> function.
							</td>
						</tr>

						<tr>
							<td><code>timeoutTask</code></td>
							<td><code>Task?</code></td>

							<td>
								The scheduled timeout task, if a timeout exists.
							</td>
						</tr>

						<tr>
							<td><code>unsortedComponents</code></td>
							<td><code>MutableList&lt;Component&gt;</code></td>

							<td>
								A list containing unsorted components, to be sorted by the <code>sort</code> function.
							</td>
						</tr>
					</table>
		        </chapter>
	        </chapter>
        </chapter>

        <chapter title="Writing an Event Handler" id="message-components-event-handler">
            <p>
                For longer-lived message components, including those that must work after the bot restarts, it may be
                better to try writing your own <a href="Events.topic">Event Handler</a>.
            </p>
        </chapter>
    </chapter>
</topic>
